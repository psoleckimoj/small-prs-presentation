+++
title = "Writing web services in Rust"
outputs = ["Reveal"]

[reveal_hugo]
theme = "black"
+++

# Are we web yet?

Writing web services in Rust

---

## What is Rust?

- general purpose programming language
- announced by Mozilla in 2010
- "C" style syntax
- features you would expect from a modern language
- rising popularity amongst developers

{{% note %}}
- [Number one most loved language among the 65,000 programmers in StackOverflow survey 2021](https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/)
{{% /note %}}

---

## Performance

- compiled language with no run time
- no garbage collector

{{% note %}}
- **no garbage collector:** memory is managed at compile time with lifetimes and the borrow checker, resulting in higher performance and lower memory footprint
{{% /note %}}

---

## Reliability

- statically typed
- type system ensures errors are handled 
- ownership guarantees both memory and thread safety

{{% note %}}
- **[type system]** recoverable errors are propagated using Result, Option and enum types, unrecoverable errors can still panic
- [Microsoft: 70 percent of all security bugs are memory safety issues for the last 12 years](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/)
{{% /note %}}

---

## Productivity

- compiler provides useful error messages
- best in class package manager and build tool
- extensive documentation

{{% note %}}
- **[compiler provides useful error messages]** clean, concise errors point you the exact point of failure, often suggest a fix and make fixing easy
- **[best in class package manager and build tool]**] build, lint, format and test out the box, plugins for audit etc..
- **[extensive documentation]** consistent and accurate, generated by annotating the code, code in documentation is also tested
{{% /note %}}

---

## The Rust language

the bits I really like

---

## Error handling

{{< highlight rust "linenos=inline" >}}
async fn init_db() -> Result<PgPool, Error> {
    let database_url = env::var("DATABASE_URL")?;

    match PgPoolOptions::new()
        .connect(&database_url)
        .await {
            Ok(pool) => {
                sqlx::migrate!("db/migrations")
                    .run(&pool)
                    .await?;
                Ok(pool)
            }, 
            Err(e) => Err(e.into())
        }
}
{{< / highlight >}}

{{% note %}}
- **[example]** Result types have to be handled, when designing the API of a library you would want to propagate errors and allow the consumer to either try and recover or panic
- **[example]** we propagate with **?** and **match** to apply migrations if we are able to create a connection pool
{{% /note %}}

---

{{% section %}}

## Trait system

Derivable traits

{{< highlight rust "linenos=inline" >}}
#[derive(Debug, Deserialize, Serialize)]
struct Person {
    first_name: String,
    family_name: String,
    date_of_birth: Date,
}
{{< / highlight >}}

{{% note %}}
- **[example]** code generation reduces the need to write boilerplate and speed up development
{{% /note %}}

---

Implementing a trait

{{< highlight rust "linenos=inline" >}}
impl From<Claims> for ReadUser {
    fn from(claims: Claims) -> Self {
        ReadUser {
            username: claims.sub,
        }
    }
}

// Implementing this would allow for the following
//
// let user = ReadUser::from(claims);
// let user: ReadUser = claims.into();
// fn some_function(user: dyn Into<ReadUser>) {}
{{< / highlight >}}

{{% note %}}
- **[example]** they act like java interfaces
- **[example]** some traits will give you implementations for others  e.g **impl From\<A\> for B** gives you **impl Into\<B\> for A**
- **[example]** we can extend structs from libraries
- **[example]** we can use them for operator overloading
{{% /note %}}

{{% /section %}}

---

{{% section %}}

## Pattern matching

{{< highlight rust "linenos=inline,hl_lines=3-6" >}}
impl IntoResponse for ApiError {
    fn into_response(self) -> axum::response::Response {
        let validation_errors = match &self {
            ApiError::ValidationError(e) => Some(e),
            _ => None,
        };

        (
            self.status_code(),
            Json(ErrorResponse {
                message: &self,
                errors: validation_errors,
            }),
        ).into_response()
    }
}
{{< / highlight >}}

{{% note %}}
- **[example]** we're using **match** to return an optional value for the validation variant of the error enum
{{% /note %}}

---

They're exhaustive

{{< highlight rust "linenos=inline" >}}
fn handle_error(error: sqlx::Error) {
    match error {
        sqlx::Error::Configuration(_) => todo!(),
        sqlx::Error::Database(_) => todo!(),
        sqlx::Error::Io(_) => todo!(),
        sqlx::Error::Tls(_) => todo!(),
        sqlx::Error::Protocol(_) => todo!(),
        sqlx::Error::RowNotFound => todo!(),
        sqlx::Error::TypeNotFound { type_name } => todo!(),
        sqlx::Error::ColumnIndexOutOfBounds { index, len } => todo!(),
        sqlx::Error::ColumnNotFound(_) => todo!(),
        sqlx::Error::ColumnDecode { index, source } => todo!(),
        sqlx::Error::Decode(_) => todo!(),
        sqlx::Error::PoolTimedOut => todo!(),
        sqlx::Error::PoolClosed => todo!(),
        sqlx::Error::WorkerCrashed => todo!(),
        sqlx::Error::Migrate(_) => todo!(),
        _ => todo!(),
    }
}
{{< / highlight >}}

{{% note %}}
- **[example]** match statements are required to be exhaustive
- **[example]** we can include a default handle with **_**
- **[example]** they're powerful we can use complex expressions, in this example we have an enum where variants include unit, tuple and struct enum type
{{% /note %}}

{{% /section %}}

---

## Rust for web services

I built a thing and this is what I learned

---

{{% section %}}

## axum

- web framework
- part of the Tokio ecosystem
- uses Hyper HTTP libraries
- minimal boilerplate
- really fast[*](https://web-frameworks-benchmark.netlify.app/compare?f=axum,spring,express)

{{% note %}}
- [**axum**] tokio is an async runtime, Rust provides the language constructs and the runtimes are built by the community
- [**axum**] the tokio ecosystem popular choice with backing from contributors such as Amazon, Microsoft and Facebook
- [**benchmarks**] Axum ~140k req/s vs Spring ~70k req/s vs Express ~25k req/s with around half the latency of Spring
{{% /note %}}

---

### What it looks like

{{< highlight rust "linenos=inline" >}}
#[tokio::main]
async fn main() {
    let app = Router::new().route("/", get(say_hello));
    
    let addr = SocketAddr::from(([127, 0, 0, 1], 8080));
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn say_hello() -> Html<&'static str> {
    Html("Hello, World!")
}
{{< / highlight >}}

{{% note %}}
- [**example**] axum leverages the the type system, using generics and traits to minimise boilerplate
- [**example**] handlers are just async functions that take parameters implementing the FromRequest trait and return values implementing the ToResponse trait
{{% /note %}}

---

### Other web frameworks

- Actix web
    - tried and tested
    - originally built upon the Actix library

- Rocket
    - simple use of macros for code-gen
    - good quality documentation

{{% note %}}
- [**actix**] its being one of the older frameworks it has lots of examples
- [**rocket**] quite opinionated, you get a lot of stuff for free similar to Springboot but you also have to do things their way
{{% /note %}}

{{% /section %}}

---

{{% section %}}

## sqlx

- supports PostgreSQL, MySQL, SQLite, and MSSQL
- compatible with multiple async runtimes
- it's not an ORM
- queries are checked at compile time

---

## Executing queries

```rust
let person = sqlx::query_as!(
    Person,
    r#"
        INSERT INTO person (first_name, family_name, date_of_birth)
        VALUES ($1, $2, $3)
        RETURNING uuid AS id, created, last_edited, first_name, family_name, date_of_birth;
    "#,
    request.first_name,
    request.family_name,
    request.date_of_birth
)
.fetch_one(&db)
.await?;
```

{{% note %}}
- [**example**] We use the **query_as!** macro which allows use specify a type to deserialize the result to, the SQL statement is then checked against the database at compile time
- [**example**] Really cool trick, the **rust-analyser** extension expands this macro when writing code, so you get feedback before you even run **cargo build**
{{% /note %}}


---

## Applying migrations

Programmatically

{{< highlight rust "linenos=inline" >}}
sqlx::migrate!("db/migrations").run(&pool).await?;
{{< / highlight >}}

Using the CLI

{{< highlight sh "linenos=inline" >}}
sqlx migrate run --source=db/migrations
{{< / highlight >}}

{{% note %}}
- [**sqlx**] migrations remind me of Flyway, you just write SQL and go
{{% /note %}}

---

### If you want to use an ORM

- Diesel
    - a mature library
    - robust compile time type checking

- SeaOrm
    - async
    - built upon sqlx
    - really good tooling with the CLI

{{% note %}}
- [**diesel**] async will be added as part of the next major release
- [**seaorm**] schema first, the tooling allows you to generate code for entities from a database schema
{{% /note %}}

{{% /section %}}

---

{{% section %}}

## serde and validator

- Serde
    - JSON serialization and deserialization
    - derive macros make things quick and easy
- Validator
    - macro based validation for DTOs
    - a lot of validation out the box
    - extendable

{{% note %}}
- [**serde**] not limited to JSON, similar to Jackson in Java we can serialize and deserialize many types of data
- [**validator**] out of the box you get validation for numerical values and string types such as credit card and telephone numbers
- [**validator**] can be extended with simple functions
{{% /note %}}

--- 

## Building a DTO

{{< highlight rust "linenos=inline" >}}
#[derive(Debug, Validate, Deserialize)]
pub struct NewPerson {
    #[validate(length(min = 1, max = 64))]
    first_name: String,
    #[validate(length(min = 1, max = 64))]
    family_name: String,
    #[validate(custom = "date_not_in_future")]
    date_of_birth: Date,
}
{{< / highlight >}}

{{% note %}}
- [**example**] code gen through macros make it really easy to configure with simple values
{{% /note %}}

---

## Running the validation

{{< highlight rust "linenos=inline, hl_lines=5" >}}
async fn create_person(
    db: Extension<PgPool>,
    Json(request): Json<NewPerson>,
) -> Result<(StatusCode, Json<Person>), ApiError> {
    request.validate()?;
    // ...
}
{{< / highlight >}}

{{% note %}}
- [**example**] combining this with a library like thiserror you will be able to convert the error and propagate it using the **?** operator
{{% /note %}}

{{% /section %}}

---

## So what did I not like?

- maturity of some of the libraries
- documentation is generally good, but examples can be lacking
- the borrow checker and lifetimes still kick my ass from time to time

{{% note %}}
- [**maturity**] there's still some issues where you need some features from a new update but other libraries use incompatible versions
- [**examples can be lacking**] specifically real world examples for newer libraries that have less usage
- [**the borrow checker**] not a bad thing just a learning curve
{{% /note %}}

---

## Useful links

- [the official Rust website](https://www.rust-lang.org/)
- [the Rust book](https://doc.rust-lang.org/book/)
- [are we web yet?](https://www.arewewebyet.org/)
- [my rust web service](https://github.com/LucasCairns/rust-web-app)

---

# Questions? ðŸ¤”
